/**
 * This file is part of Aion-Lightning <aion-lightning.org>.
 *
 *  Aion-Lightning is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Aion-Lightning is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details. *
 *  You should have received a copy of the GNU General Public License
 *  along with Aion-Lightning.
 *  If not, see <http://www.gnu.org/licenses/>.
 */


package com.aionemu.gameserver.services;

import com.aionemu.commons.utils.Rnd;

import java.util.*;

import com.aionemu.gameserver.model.gameobjects.player.AbyssRank;
import com.aionemu.gameserver.model.stats.calc.functions.StatFunction;
import com.aionemu.gameserver.world.World;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javolution.util.FastMap;

import com.aionemu.gameserver.configs.main.CustomConfig;
import com.aionemu.gameserver.configs.main.EternityConfig;
import com.aionemu.gameserver.configs.main.GroupConfig;
import com.aionemu.gameserver.configs.main.LoggingConfig;
import com.aionemu.gameserver.configs.main.PunishmentConfig;
import com.aionemu.gameserver.configs.main.RateConfig;
import com.aionemu.gameserver.controllers.attack.AggroInfo;
import com.aionemu.gameserver.controllers.attack.KillList;
import com.aionemu.gameserver.model.DescriptionId;
import com.aionemu.gameserver.model.gameobjects.player.Player;
import com.aionemu.gameserver.model.gameobjects.player.RewardType;
import com.aionemu.gameserver.model.ingameshop.InGameShopEn;
import com.aionemu.gameserver.model.team2.alliance.PlayerAlliance;
import com.aionemu.gameserver.model.team2.group.PlayerGroup;
import com.aionemu.gameserver.network.aion.serverpackets.SM_SYSTEM_MESSAGE;
import com.aionemu.gameserver.questEngine.QuestEngine;
import com.aionemu.gameserver.questEngine.model.QuestEnv;
import com.aionemu.gameserver.services.abyss.AbyssPointsService;
import com.aionemu.gameserver.services.ecfunctions.crazy_daeva.CrazyDaevaService;
import com.aionemu.gameserver.services.item.ItemService;
import com.aionemu.gameserver.utils.audit.AuditLogger;
import com.aionemu.gameserver.utils.MathUtil;
import com.aionemu.gameserver.utils.PacketSendUtility;
import com.aionemu.gameserver.utils.i18n.CustomMessageId;
import com.aionemu.gameserver.utils.i18n.LanguageHandler;
import com.aionemu.gameserver.utils.stats.AbyssRankEnum;
import com.aionemu.gameserver.utils.stats.StatFunctions;

/**
 * @author Sarynth
 */
public class PvpService {

    private static Logger log = LoggerFactory.getLogger("KILL_LOG");

    public static final PvpService getInstance() {
        return SingletonHolder.instance;
    }
    private FastMap<Integer, KillList> pvpKillLists;
    public static String vicName = "";

    private PvpService() {
        pvpKillLists = new FastMap<Integer, KillList>();
    }

    /**
     * @param winnerId
     * @param victimId
     * @return
     */
    private int getKillsFor(int winnerId, int victimId) {
        KillList winnerKillList = pvpKillLists.get(winnerId);

        if (winnerKillList == null) {
            return 0;
        }
        return winnerKillList.getKillsFor(victimId);
    }

    /**
     * @param winnerId
     * @param victimId
     */
    private void addKillFor(int winnerId, int victimId) {
        KillList winnerKillList = pvpKillLists.get(winnerId);
        if (winnerKillList == null) {
            winnerKillList = new KillList();
            pvpKillLists.put(winnerId, winnerKillList);
        }
        winnerKillList.addKillFor(victimId);
    }

    private void AdvancedPvPMap(Player winner, Player victim) {
        int winnerKills = winner.getRawKillCount();
       // Calendar calendar = Calendar.getInstance();
        if (CustomConfig.ADVANCED_PVP_SYSTEM) {
           // if (calendar.get(Calendar.DAY_OF_WEEK) == Calendar.MONDAY || calendar.get(Calendar.DAY_OF_WEEK) == Calendar.WEDNESDAY) {
                if (winner.getWorldId() == 220070000 || winner.getWorldId() == 210050000 || winner.getWorldId() == 600040000) {
                    if(winner.getSpreeLevel() == 1){
                        AbyssPointsService.addAp(winner, + CustomConfig.ADVANCED_AP_REWARD);
                        AbyssPointsService.addGp(winner, + CustomConfig.ADVANCED_GP_REWARD);
                    }
                    if(winner.getSpreeLevel() == 2){
                        AbyssPointsService.addAp(winner, + CustomConfig.ADVANCED_AP_REWARD + 100);
                        AbyssPointsService.addGp(winner, + CustomConfig.ADVANCED_GP_REWARD + 100);
                    }
                    if(winner.getSpreeLevel() == 3){
                        AbyssPointsService.addAp(winner, + CustomConfig.ADVANCED_AP_REWARD + 200);
                        AbyssPointsService.addGp(winner, + CustomConfig.ADVANCED_GP_REWARD + 200);
                    }
                    PacketSendUtility.sendMessage(winner, "[PvP System] You kill player " + victim.getName() + "! ( PvP Kill Count : " + winnerKills + ")");
                    String message = "";

                    customMsg(winner, victim, message);

            /*
                    final Player win = victim.getAggroList().getMostPlayerDamage();
                    Iterator<Player> ita = World.getInstance().getPlayersIterator();

                    while(ita.hasNext()){
                        PacketSendUtility.sendYellowMessageOnCenter(ita.next(), "[PvP] : " + win.getName() + " has killed player " + victim.getName() + " !!");
                    }
            */

           //     }
          //  } else if (calendar.get(Calendar.DAY_OF_WEEK) == Calendar.TUESDAY) {
          //      if (winner.getWorldId() == 220070000 || winner.getWorldId() == 210050000) {
          //          AbyssPointsService.addAp(winner, +CustomConfig.ADVANCED_AP_REWARD);
			//		AbyssPointsService.addGp(winner, +CustomConfig.ADVANCED_GP_REWARD);
           //         PacketSendUtility.sendMessage(winner, LanguageHandler.translate(CustomMessageId.ADV_WINNER_MSG) + victim.getName() + "!");
           //     }
           // } else if (calendar.get(Calendar.DAY_OF_WEEK) == Calendar.THURSDAY) {
           //     if (winner.getWorldId() == 220070000 || winner.getWorldId() == 210050000) {
           //         AbyssPointsService.addAp(winner, +CustomConfig.ADVANCED_AP_REWARD);
			//		AbyssPointsService.addGp(winner, +CustomConfig.ADVANCED_GP_REWARD);
           //         PacketSendUtility.sendMessage(winner, LanguageHandler.translate(CustomMessageId.ADV_WINNER_MSG) + victim.getName() + "!");
           //     }
           // } else if (calendar.get(Calendar.DAY_OF_WEEK) == Calendar.FRIDAY) {
           //     if (winner.getWorldId() == 220070000 || winner.getWorldId() == 210050000) {
           //         AbyssPointsService.addAp(winner, +CustomConfig.ADVANCED_AP_REWARD);
			//		AbyssPointsService.addGp(winner, +CustomConfig.ADVANCED_GP_REWARD);
           //         PacketSendUtility.sendMessage(winner, LanguageHandler.translate(CustomMessageId.ADV_WINNER_MSG) + victim.getName() + "!");
           //     }
          //  } else if (calendar.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY) {
           //     if (winner.getWorldId() == 220070000 || winner.getWorldId() == 210050000) {
           //         AbyssPointsService.addAp(winner, +CustomConfig.ADVANCED_AP_REWARD);
			//		AbyssPointsService.addGp(winner, +CustomConfig.ADVANCED_GP_REWARD);
           //         PacketSendUtility.sendMessage(winner, LanguageHandler.translate(CustomMessageId.ADV_WINNER_MSG) + victim.getName() + "!");
           //     }
           // } else if (calendar.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY) {
           //     if (winner.getWorldId() == 220070000 || winner.getWorldId() == 210050000) {
           //         AbyssPointsService.addAp(winner, +CustomConfig.ADVANCED_AP_REWARD);
			//		AbyssPointsService.addGp(winner, +CustomConfig.ADVANCED_GP_REWARD);
           //         PacketSendUtility.sendMessage(winner, LanguageHandler.translate(CustomMessageId.ADV_WINNER_MSG) + victim.getName() + "!");
           //     }
            }
        }
    }

    private void customMsg(Player winner, Player victim, String msg){
        int rng = Rnd.get(1,10);
        String mostDmgWinner = victim.getAggroList().getMostPlayerDamage().getName();
        int winnerKills = winner.getRawKillCount();
        if(mostDmgWinner.equalsIgnoreCase(vicName)){
            return;
        }else{
            vicName = mostDmgWinner;
        }
        if(winnerKills == 5 || winnerKills == 10 || winnerKills == 20){
            return;
        }

        switch (rng){
            case 1:
                msg = "[Insane PvP] Some OP player named " + mostDmgWinner + " has killed " + victim.getName() + " in PvP! and has " + winnerKills + " kills.";
                break;
            case 2:
                msg = "[Insane PvP] Player " + mostDmgWinner + " has murdered " + victim.getName() + " so easily! and now he has " + winnerKills + " kills.";
                break;
            case 3:
                msg = "[Insane PvP] " + mostDmgWinner + " : The easiest kill i've ever killed was " + victim.getName() + "! now i have " + winnerKills + " kills.";
                break;
            case 4:
                msg = "[Insane PvP] MOOOOOOONNNSTAARRR KILL!!! " + mostDmgWinner + " has killed " + victim.getName() + "!! now increasing with " + winnerKills + " kills.";
                break;
            case 5:
                msg = "[Insane PvP] " + mostDmgWinner + " THAT WAS SO EZ!!!";
                break;
            case 6:
                msg = "[Insane PvP] " + mostDmgWinner + " Nailed it!! Killed " + victim.getName() + "!";
                break;
            case 7:
                msg = "[Insane PvP] [color:INSA;1 0 0][color:NE;1 0 0] [color:KILL;1 0 0] [color:!!!;1 0 0] by " + mostDmgWinner + "!!";
                break;
            case 8:
                msg = "[Insane PvP] " + mostDmgWinner + "is on [color:ULTR;1 0 0][color:AA;1 0 0] [color:KILL;1 0 0][color:LL!!;1 0 0] after killing " + victim.getName() +" !! (Kills : " + winnerKills + " )";
                break;
            case 9:
                msg = "[Insane PvP] " + mostDmgWinner + ": this is how you kill a nub :)";
                break;
            case 10:
                msg = "[Insane PvP] Someone Quickly Stop this " + mostDmgWinner + " from increasing his Spree!!";
                break;
        }
        if(winnerKills == 1){
            msg = "[Insane PvP] " + mostDmgWinner + " just took his first Kill!!";
        }
        if(winnerKills == 9){
            msg = "[Insane PvP] Player " + mostDmgWinner + " is on [color:RAMP;1 0 0][color:AGE!;1 0 0][color:!!;1 0 0] someone end it before its too late!!!";
        }
        if(winnerKills == 2){
            msg = "[Insane PvP] " + mostDmgWinner + " just took DOUBLE KILL !!";
        }
        if(winnerKills == 15){
            msg = "[Insane PvP] " + mostDmgWinner + " is [color:UNNS;1 0 0][color:TOPP;1 0 0][color:IABL;1 0 0][color:LEE;1 0 0] [color:!!!!;1 0 0] (Kills : " + winnerKills + " )";
        }
        for (Player p : World.getInstance().getAllPlayers()){
            if(p.getWorldId() == 220070000 || p.getWorldId() == 600040000){
                PacketSendUtility.sendBrightYellowMessageOnCenter(p, msg);
            }
        }
    }

    private void SpecialReward(Player winner, Player victim) {
        if (winner.getLevel() - victim.getLevel() <= CustomConfig.MAX_AUTHORIZED_LEVEL_DIFF) {
            if (getKillsFor(winner.getObjectId().intValue(), victim.getObjectId().intValue()) < CustomConfig.MAX_DAILY_PVP_KILLS) {
                if (CustomConfig.ENABLE_MEDAL_REWARDING) {
                    if (Rnd.get() * 100 < PvPRewardService.getMedalRewardChance(winner, victim)) {
                        int medalId = PvPRewardService.getRewardId(winner, victim, false);
                        int medalCount = 1;
                        ItemService.addItem(winner, medalId, medalCount);
                        if (winner.getInventory().getItemCountByItemId(medalId) > 0) {
                            //if (medalCount == 1) {
                            PacketSendUtility.sendPacket(winner, new SM_SYSTEM_MESSAGE(1390000, new DescriptionId(medalId)));
                            /*} else {
                             PacketSendUtility.sendPacket(winner, new SM_SYSTEM_MESSAGE(1390005, medalCount, new DescriptionId(medalId)));
                             }*/
                        }
                    }
                }
                if ((CustomConfig.ENABLE_TOLL_REWARDING) && (Rnd.get() * 100.0F < PvPRewardService.getTollRewardChance(winner, victim))) {
                    int qt = PvPRewardService.getTollQuantity(winner, victim);
                    InGameShopEn.getInstance().addToll(winner, qt);
                    if (qt == 1) {
                        PacketSendUtility.sendBrightYellowMessage(winner, LanguageHandler.translate(CustomMessageId.PVP_TOLL_REWARD1) + qt + LanguageHandler.translate(CustomMessageId.PVP_TOLL_REWARD2));
                    } else {
                        PacketSendUtility.sendBrightYellowMessage(winner, LanguageHandler.translate(CustomMessageId.PVP_TOLL_REWARD1) + qt + LanguageHandler.translate(CustomMessageId.PVP_TOLL_REWARD2));
                    }
                }
                if (CustomConfig.GENOCIDE_SPECIAL_REWARDING != 0) {
                    switch (CustomConfig.GENOCIDE_SPECIAL_REWARDING) {
                        case 1:
                            if ((winner.getSpreeLevel() <= 2) || (Rnd.get() * 100 >= CustomConfig.SPECIAL_REWARD_CHANCE)) {
                                break;
                            }
                            int abyssId = PvPRewardService.getRewardId(winner, victim, true);
                            ItemService.addItem(winner, abyssId, 1L);
                            log.info("[PvP][Advanced] {Player : " + winner.getName() + "} has won " + abyssId + " for killing {Player : " + victim.getName() + "}");
                            break;
                        default:
                            if ((winner.getSpreeLevel() <= 2) || (Rnd.get() * 100 >= CustomConfig.SPECIAL_REWARD_CHANCE)) {
                                break;
                            }
                            ItemService.addItem(winner, CustomConfig.GENOCIDE_SPECIAL_REWARDING, 1L);
                            log.info("[PvP][Advanced] {Player : " + winner.getName() + "} has won " + CustomConfig.GENOCIDE_SPECIAL_REWARDING + " for killing {Player : " + victim.getName() + "}");
                            break;
                    }
                }
            } else {
                PacketSendUtility.sendMessage(winner, LanguageHandler.translate(CustomMessageId.PVP_NO_REWARD1) + victim.getName() + LanguageHandler.translate(CustomMessageId.PVP_NO_REWARD2));
            }
        }
    }

    /**
     * @param victim
     */
    public void doReward(Player victim) {
        // winner is the player that receives the kill count
        final Player winner = victim.getAggroList().getMostPlayerDamage();

        int totalDamage = victim.getAggroList().getTotalDamage();

        if (totalDamage == 0 || winner == null || winner.getRace() == victim.getRace()) {
            return;
        }

        if (victim.getBattleGround() != null) {
            return;
        }

        int dailyPvPKill = 0;
        if (winner.isInGroup2() || winner.isInAlliance2()) {
            Collection<Player> members = null;
            if (winner.isInGroup2()) {
                members = winner.getPlayerGroup2().getMembers();
            } else {
                members = winner.getPlayerAlliance2().getOnlineMembers();
            }

            for (Player p : members) {
                dailyPvPKill = getKillsFor(p.getObjectId(), victim.getObjectId());

                if (dailyPvPKill < CustomConfig.MAX_DAILY_PVP_KILLS && MathUtil.isIn3dRange(p, victim, GroupConfig.GROUP_MAX_DISTANCE)) {
                    p.getAbyssRank().updateKillCounts();
                    if (CustomConfig.ENABLE_KILL_REWARD && (victim.getRace() != winner.getRace())) {
                        SpecialReward(p, victim);
                    }
                }
            }
        } else {
            dailyPvPKill = getKillsFor(winner.getObjectId(), victim.getObjectId());

            if (dailyPvPKill < CustomConfig.MAX_DAILY_PVP_KILLS && MathUtil.isIn3dRange(winner, victim, GroupConfig.GROUP_MAX_DISTANCE)) {
                winner.getAbyssRank().updateKillCounts();
                if (CustomConfig.ENABLE_KILL_REWARD) {
                    SpecialReward(winner, victim);
                }
            }
        }

        //Crazy kill
        if (EternityConfig.ENABLE_CRAZY) {
            if (winner.getRndCrazy() >= EternityConfig.CRAZY_LOWEST_RND) {
                AbyssPointsService.addAp(winner, 500);
				AbyssPointsService.addGp(winner, 25);
            }
        }

        // Announce that player has died.
        PacketSendUtility.broadcastPacketAndReceive(victim, SM_SYSTEM_MESSAGE.STR_MSG_COMBAT_FRIENDLY_DEATH_TO_B(victim.getName(), winner.getName()));

        // Pvp Kill Reward.
        int reduceap = PunishmentConfig.PUNISHMENT_REDUCEAP;
        int reducegp = PunishmentConfig.PUNISHMENT_REDUCEGP;

        if (reduceap < 0) {
            reduceap *= -1;
        }
        if (reduceap > 100) {
            reduceap = 100;
        }
        if (reducegp < 0) {
            reducegp *= -1;
        }
        if (reducegp > 100) {
            reducegp = 100;
        }


        //Kill-log
        if (LoggingConfig.LOG_KILL) {
            log.info("[KILL] Player [" + winner.getName() + "] killed [" + victim.getName() + "]");
        }

        if ((LoggingConfig.LOG_PL) || (reduceap > 0)) {
            String ip1 = winner.getClientConnection().getIP();
            String mac1 = winner.getClientConnection().getMacAddress();
            String ip2 = victim.getClientConnection().getIP();
            String mac2 = victim.getClientConnection().getMacAddress();
            if ((mac1 != null) && (mac2 != null)) {
                if ((ip1.equalsIgnoreCase(ip2)) && (mac1.equalsIgnoreCase(mac2))) {
                    AuditLogger.info(winner, "Power Leveling : " + winner.getName() + " with " + victim.getName() + ", They have the sames ip=" + ip1 + " and mac=" + mac1 + ".");
                    if (reduceap > 0) {
                        int win_ap = winner.getAbyssRank().getAp() * reduceap / 100;
                        int vic_ap = victim.getAbyssRank().getAp() * reduceap / 100;
                        int win_gp = winner.getAbyssRank().getGp() * reducegp / 100;
                        int vic_gp = victim.getAbyssRank().getGp() * reducegp / 100;
                        AbyssPointsService.addAp(winner, -win_ap);
                        AbyssPointsService.addAp(victim, -vic_ap);
                        AbyssPointsService.addGp(winner, -win_gp);
                        AbyssPointsService.addGp(victim, -vic_gp);
                        PacketSendUtility.sendMessage(winner, "[ PL ​​- AP ] You lost " + reduceap + " % of your AP .");
                        PacketSendUtility.sendMessage(victim, "[ PL ​​- AP ] You lost " + reduceap + " % of your AP .");
                        PacketSendUtility.sendMessage(winner, "[ PL ​​- AP ] You lost " + reducegp + " % of your AP .");
                        PacketSendUtility.sendMessage(victim, "[ PL ​​- AP ] You lost " + reducegp + " % of your AP .");

                    }
                    return;
                }
                if (ip1.equalsIgnoreCase(ip2)) {
                    AuditLogger.info(winner, "Possible Power Leveling : " + winner.getName() + " with " + victim.getName() + ", They have the sames ip=" + ip1 + ".");
                    AuditLogger.info(winner, "Check if " + winner.getName() + " and " + victim.getName() + " are Brothers-Sisters-Lovers-dogs-cats...");
                }
            }
        }

        // Keep track of how much damage was dealt by players
        // so we can remove AP based on player damage...
        int playerDamage = 0;
        boolean success;

        // Distribute AP to groups and players that had damage.
        for (AggroInfo aggro : victim.getAggroList().getFinalDamageList(true)) {
            success = false;
            if (aggro.getAttacker() instanceof Player) {
                success = rewardPlayer(victim, totalDamage, aggro);
            } else if (aggro.getAttacker() instanceof PlayerGroup) {
                success = rewardPlayerGroup(victim, totalDamage, aggro);
            } else if (aggro.getAttacker() instanceof PlayerAlliance) {
                success = rewardPlayerAlliance(victim, totalDamage, aggro);
            }

            // Add damage last, so we don't include damage from same race. (Duels, Arena)
            if (success) {
                playerDamage += aggro.getDamage();
            }
        }

        SerialKillerService.getInstance().updateRank(winner, victim);

        //notify Quest engine for winner + his group
        notifyKillQuests(winner, victim);

        // Apply lost AP to defeated player
        final int apLost = StatFunctions.calculatePvPApLost(victim, winner);
        final int apActuallyLost = (int) (apLost * playerDamage / totalDamage);

        if (apActuallyLost > 0) {
            AbyssPointsService.addAp(victim, -apActuallyLost);
        }

        // Apply lost GP to defeated player
        final int gpLost = StatFunctions.calculatePvPGpLost(victim, winner);
        final int gpActuallyLost = (int) (gpLost * playerDamage / totalDamage);

        if(gpActuallyLost > 0){
            AbyssPointsService.addGp(victim, -gpActuallyLost);
        }

        PvPSpreeService.cancelSpree(victim,winner,true);

        //todo gp add lose... done

    }

    /**
     * @param victim
     * @param totalDamage
     * @param aggro
     * @return true if group is not same race
     */
    private boolean rewardPlayerGroup(Player victim, int totalDamage, AggroInfo aggro) {
        // Reward Group
        PlayerGroup group = ((PlayerGroup) aggro.getAttacker());

        // Don't Reward Player of Same Faction.
        if (group.getRace() == victim.getRace()) {
            return false;
        }

        // Find group members in range
        List<Player> players = new ArrayList<Player>();

        // Find highest rank and level in local group
        int maxRank = AbyssRankEnum.GRADE9_SOLDIER.getId();
        int maxLevel = 0;

        for (Player member : group.getMembers()) {
            if (MathUtil.isIn3dRange(member, victim, GroupConfig.GROUP_MAX_DISTANCE)) {
                // Don't distribute AP to a dead player!
                if (!member.getLifeStats().isAlreadyDead()) {
                    players.add(member);
                    if (member.getLevel() > maxLevel) {
                        maxLevel = member.getLevel();
                    }
                    if (member.getAbyssRank().getRank().getId() > maxRank) {
                        maxRank = member.getAbyssRank().getRank().getId();
                    }
                }
            }
        }

        // They are all dead or out of range.
        if (players.isEmpty()) {
            return false;
        }

        //TODO ADD GP GAIN;;; done


        int baseApReward = StatFunctions.calculatePvpApGained(victim, maxRank, maxLevel);
        int baseGpReward = StatFunctions.calculatePvpGpGained(victim, maxRank, maxLevel);
        int baseXpReward = StatFunctions.calculatePvpXpGained(victim, maxRank, maxLevel);
        int baseDpReward = StatFunctions.calculatePvpDpGained(victim, maxRank, maxLevel);
        float groupPercentage = (float) aggro.getDamage() / totalDamage;
        int apRewardPerMember = Math.round(baseApReward * groupPercentage / players.size());
        int gpRewardPerMember = Math.round(baseGpReward * groupPercentage / players.size());
        int xpRewardPerMember = Math.round(baseXpReward * groupPercentage / players.size());
        int dpRewardPerMember = Math.round(baseDpReward * groupPercentage / players.size());

        for (Player member : players) {
            int memberApGain = 1;
            int memberGpGain = 1;
            int memberXpGain = 1;
            int memberDpGain = 1;
            if (this.getKillsFor(member.getObjectId(), victim.getObjectId()) < CustomConfig.MAX_DAILY_PVP_KILLS) {
                if (apRewardPerMember > 0) {
                    memberApGain = Math.round(RewardType.AP_PLAYER.calcReward(member, apRewardPerMember));
                }
                if (gpRewardPerMember > 0) {
                    memberGpGain = Math.round(RewardType.GP_PLAYER.calcReward(member, gpRewardPerMember));
                }
                if (xpRewardPerMember > 0) {
                    memberXpGain = Math.round(xpRewardPerMember * member.getRates().getXpPlayerGainRate());
                }
                if (dpRewardPerMember > 0) {
                    memberDpGain = Math.round(StatFunctions.adjustPvpDpGained(dpRewardPerMember, victim.getLevel(), member.getLevel()) * member.getRates().getDpPlayerRate());
                }

            }
            AdvancedPvPMap(member, victim);
            Player partner = member.findPartner();
            if (member.isMarried() && member.getPlayerGroup2().getMembers() == partner && member.getPlayerGroup2().getMembers().size() == 2) {
                AbyssPointsService.addAp(member, victim, memberApGain + (memberApGain * 20 / 100)); //20% more AP for weddings
				AbyssPointsService.addGp(member, victim, 15); //20% more GP for weddings
            } else {
                AbyssPointsService.addAp(member, victim, memberApGain);
				AbyssPointsService.addGp(member, victim, memberGpGain);
            }
            member.getCommonData().addExp(memberXpGain, RewardType.PVP_KILL, victim.getName());
            member.getCommonData().addDp(memberDpGain);
            this.addKillFor(member.getObjectId(), victim.getObjectId());
        }

        return true;
    }

    /**
     * @param victim
     * @param totalDamage
     * @param aggro
     * @return true if group is not same race
     */
    private boolean rewardPlayerAlliance(Player victim, int totalDamage, AggroInfo aggro) {
        // Reward Alliance
        PlayerAlliance alliance = ((PlayerAlliance) aggro.getAttacker());

        // Don't Reward Player of Same Faction.
        if (alliance.getLeaderObject().getRace() == victim.getRace()) {
            return false;
        }

        // Find group members in range
        List<Player> players = new ArrayList<Player>();

        // Find highest rank and level in local group
        int maxRank = AbyssRankEnum.GRADE9_SOLDIER.getId();
        int maxLevel = 0;

        for (Player member : alliance.getMembers()) {
            if (!member.isOnline()) {
                continue;
            }
            if (MathUtil.isIn3dRange(member, victim, GroupConfig.GROUP_MAX_DISTANCE)) {
                // Don't distribute AP to a dead player!
                if (!member.getLifeStats().isAlreadyDead()) {
                    players.add(member);
                    if (member.getLevel() > maxLevel) {
                        maxLevel = member.getLevel();
                    }
                    if (member.getAbyssRank().getRank().getId() > maxRank) {
                        maxRank = member.getAbyssRank().getRank().getId();
                    }
                }
            }
        }

        // They are all dead or out of range.
        if (players.isEmpty()) {
            return false;
        }

        int baseApReward = StatFunctions.calculatePvpApGained(victim, maxRank, maxLevel);
        int baseGpReward = StatFunctions.calculatePvpGpGained(victim, maxRank, maxLevel);
        int baseXpReward = StatFunctions.calculatePvpXpGained(victim, maxRank, maxLevel);
        int baseDpReward = StatFunctions.calculatePvpDpGained(victim, maxRank, maxLevel);
        float groupPercentage = (float) aggro.getDamage() / totalDamage;
        int apRewardPerMember = Math.round(baseApReward * groupPercentage / players.size());
        int gpRewardPerMember = Math.round(baseGpReward * groupPercentage / players.size());
        int xpRewardPerMember = Math.round(baseXpReward * groupPercentage / players.size());
        int dpRewardPerMember = Math.round(baseDpReward * groupPercentage / players.size());

        for (Player member : players) {
            int memberApGain = 1;
            int memberGpGain = 1;
            int memberXpGain = 1;
            int memberDpGain = 1;
            if (this.getKillsFor(member.getObjectId(), victim.getObjectId()) < CustomConfig.MAX_DAILY_PVP_KILLS) {
                if (apRewardPerMember > 0) {
                    memberApGain = Math.round(RewardType.AP_PLAYER.calcReward(member, apRewardPerMember));
                }
                if (gpRewardPerMember > 0) {
                    memberGpGain = Math.round(RewardType.GP_PLAYER.calcReward(member, gpRewardPerMember));
                }
                if (xpRewardPerMember > 0) {
                    memberXpGain = Math.round(xpRewardPerMember * member.getRates().getXpPlayerGainRate());
                }
                if (dpRewardPerMember > 0) {
                    memberDpGain = Math.round(StatFunctions.adjustPvpDpGained(dpRewardPerMember, victim.getLevel(), member.getLevel()) * member.getRates().getDpPlayerRate());
                }
            }
            AdvancedPvPMap(member, victim);
            AbyssPointsService.addAp(member, victim, memberApGain);
			AbyssPointsService.addGp(member, victim, memberGpGain);
            member.getCommonData().addExp(memberXpGain, RewardType.PVP_KILL, victim.getName());
            member.getCommonData().addDp(memberDpGain);

            this.addKillFor(member.getObjectId(), victim.getObjectId());
        }

        return true;
    }

    /**
     * @param victim
     * @param totalDamage
     * @param aggro
     * @return true if player is not same race
     */
    private boolean rewardPlayer(Player victim, int totalDamage, AggroInfo aggro) {
        // Reward Player
        Player winner = ((Player) aggro.getAttacker());

        // Don't Reward Player out of range/dead/same faction
        if (winner.getRace() == victim.getRace() || !MathUtil.isIn3dRange(winner, victim, GroupConfig.GROUP_MAX_DISTANCE) || winner.getLifeStats().isAlreadyDead()) {
            return false;
        }


        //todo gP
        int baseApReward = 1;
        int baseGpReward = 1;
        int baseXpReward = 1;
        int baseDpReward = 1;

        if (this.getKillsFor(winner.getObjectId(), victim.getObjectId()) < CustomConfig.MAX_DAILY_PVP_KILLS) {
            baseApReward = StatFunctions.calculatePvpApGained(victim, winner.getAbyssRank().getRank().getId(), winner.getLevel());
            baseXpReward = StatFunctions.calculatePvpXpGained(victim, winner.getAbyssRank().getRank().getId(), winner.getLevel());
            baseDpReward = StatFunctions.calculatePvpDpGained(victim, winner.getAbyssRank().getRank().getId(), winner.getLevel());
            // SEPERATE DAILY KILLS FOR GP
            if(this.getKillsFor(winner.getObjectId(),victim.getObjectId()) < CustomConfig.MAX_DAILY_PVP_GP_KILLS){
                baseGpReward = StatFunctions.calculatePvpGpGained(victim, winner.getAbyssRank().getRank().getId(), winner.getLevel());
            }
            if (EternityConfig.ENABLE_CRAZY) {
                if (winner.getRace() != victim.getRace()) {
                    CrazyDaevaService.getInstance().increaseRawKillCount(winner);
                }
            }
                if (winner.getRace() != victim.getRace()) {
                    PvPSpreeService.increaseRawKillCount(winner);
                }
        }

        int apPlayerReward = Math.round(baseApReward * aggro.getDamage() / totalDamage);
        apPlayerReward = (int) RewardType.AP_PLAYER.calcReward(winner, apPlayerReward);
        int gpPlayerReward = Math.round(baseGpReward * aggro.getDamage() / totalDamage);
        gpPlayerReward = (int) RewardType.GP_PLAYER.calcReward(winner, gpPlayerReward);
        int xpPlayerReward = Math.round(baseXpReward * winner.getRates().getXpPlayerGainRate() * aggro.getDamage() / totalDamage);
        int dpPlayerReward = Math.round(baseDpReward * winner.getRates().getDpPlayerRate() * aggro.getDamage() / totalDamage);

        AdvancedPvPMap(winner, victim);
        AbyssPointsService.addAp(winner, victim, apPlayerReward);
		AbyssPointsService.addGp(winner, victim, gpPlayerReward);
        winner.getCommonData().addExp(xpPlayerReward, RewardType.PVP_KILL, victim.getName());
        winner.getCommonData().addDp(dpPlayerReward);
        this.addKillFor(winner.getObjectId(), victim.getObjectId());
        return true;
    }

    private void notifyKillQuests(Player winner, Player victim) {
        if (winner.getRace() == victim.getRace()) {
            return;
        }

        List<Player> rewarded = new ArrayList<Player>();
        int worldId = victim.getWorldId();

        if (winner.isInGroup2()) {
            rewarded.addAll(winner.getPlayerGroup2().getOnlineMembers());
        } else if (winner.isInAlliance2()) {
            rewarded.addAll(winner.getPlayerAllianceGroup2().getOnlineMembers());
        } else {
            rewarded.add(winner);
        }

        for (Player p : rewarded) {
            if (!MathUtil.isIn3dRange(p, victim, GroupConfig.GROUP_MAX_DISTANCE) || p.getLifeStats().isAlreadyDead()) {
                continue;
            }

            QuestEngine.getInstance().onKillInWorld(new QuestEnv(victim, p, 0, 0), worldId);
            QuestEngine.getInstance().onKillRanked(new QuestEnv(victim, p, 0, 0), victim.getAbyssRank().getRank());
        }
        rewarded.clear();
    }

    @SuppressWarnings("synthetic-access")
    private static class SingletonHolder {

        protected static final PvpService instance = new PvpService();
    }
}
